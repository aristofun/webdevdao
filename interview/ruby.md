# Вопросы по Ruby с собеседований

1. Что такое в ruby массив? хэш? строки? числа? время? символы?
    <details>
      <summary>Ответ</summary>
      
      #### Числа
      
      Числа в Ruby выглядят так:
      
      ``` rb
      5 # целое число
      -12 # отрицательное целое число
      4.5 # число с плавающей точкой
      076 # восьмеричное число
      0b010 # двоичное число
      0x89 # шестнадцатиричное число
      ```
      
      #### Логический тип
         
      Логический (булевый) тип — это вариация на тему «да» или «нет». В Ruby он представлен двумя 
      предопределёнными переменными `true` («истина» или «да») и `false` («ложь» или «нет»).
      Появляется логический тип в результате логических операций или вызова логических методов.
      
      Чаще всего логический тип возникает как результат сравнения.
      
      * Традиционно имена логических методов заканчиваются на `?` (знак вопроса).
      * В качестве `false` может выступать `nil`, а в качестве `true` — любой объект.
      * `nil` — это символ пустоты.  
      
      #### Массивы
      
      Разработчики Ruby решили не реализовывать особых классов для динамических массивов, списков, стеков и тому подобного. 
      Они все это реализовали в массивах — структурах данных типа (или класса — в Ruby всё равно) `Array`. 
      Сделано это путём добавления специальных методов; например, методы `.push` и `.pop` для стека. 
      
      Особенности массивов в Ruby:
      
      * Нет ограничений (это общий принцип языка). Массивы могут быть сколь угодно длинными.
      * Динамичность: размер массива легко меняется.
      * Гетерогенность: один массив может хранить данные разных типов.
      * Библиотека итераторов на каждый случай жизни. Эта возможность позволяет не использовать циклы для обработки 
      данных в массивах, а, следовательно, избегать множества ошибок, связанных с неосторожным обращением с циклами. 
      Итераторы реализуются на высочайшем уровне.
      * Много других методов. Все элементарные задачи для массивов решаются вызовом нужного метода.
      
      ``` rb
      [1, 0, 740, 14, 25] # целочисленный массив
      
      ["a", "й", "6", 'Br', "Это массив строк"]
      
      [[1, 2], [3, 4]] # двумерный целочисленный массив; Матрица — это объект класса Matrix
      
      # Двумерный массив — это не матрица целых чисел
      ["1-й элемент смешанного массива", "7.343", [4, "вепрь"], [3, 67, 4326, 12, 3781357, 84221, "строка делает этот подмассив смешанным, но это не беда"]]
      
      array = ["Этот массив пойдёт в переменную array", "Як-цуп-цоп, парви каридулла"]
      ```
      
      #### Строки
      
      Стро́ки — это ряды букв и других символов. В Ruby стро́ки используют наработки языка Perl. 
      
      Вот небольшой список их возможностей: 
      * Нет ограничений. Длина строки́ может достигать поистине фантастических размеров.
      * Динамичность. Стро́ки можно расширять или уменьшать (для этого есть методы `+` и `[]`).
      * Любой объект преобразуется в строку (методы `.inspect` и `.to_s` есть у любого объекта).
      * Строка обладает обширной библиотекой методов, которые работают с правилами (это методы `.gsub`, `.match`, 
      `.scan`, `.split`).
      * Можно вставлять произвольныe переменные заключив их между `#{ и }`. 
      Действует для строк начинающихся и заканчивающихся `"`. После выполнения код заместится результатом.   
      
      Стро́ки начинаются и заканчиваются `"` (программистскими кавычками) или `'` (машинописным апострофом).
      
      ``` rb
      "мама мыла раму" # строка в кавычках
      'рама сопротивлялась' # строка в апострофах
      ```
      
      #### Ассоциативные массивы
      Ассоциативные массивы подобны массивам упорядоченных пар. 
      Работают они подобно словарям: фигурная скобка символизирует боковой вид на открытую книгу, 
      а стрелка `=>` покажет читателю связь каждой сущности с какой-то другой. 
      Вторая фигурная скобка говорит, что пора закрывать книгу. В Ruby такие массивы именуются Hash.
      
      ``` rb
      hash = {"мама"=>"мыла раму", 807=>"Это число улыбается!"}
      ```
      
      Но можно и без фигурных скобок, одной стрелкой:
      
      ``` rb
      "Превед"=>"Медвед"
      ```
      
      Например:
      
      ``` rb
      puts hash["мама"] #=> мыла раму
      puts hash["807"] #=> nil
      puts hash[807] #=> Это число улыбается!
      puts hash[1] #=> nil
      puts hash["Превед"] #=> Медвед
      ```
      
      Ассоциативные массивы оставляют возможность хранения данных разного типа только в ассоциативном виде.  
      
      #### Диапазоны значений
      Чтобы было удобней получать подмассив или подстроку, был введён простенький тип данных — диапазон (класс `Range`).
      Диапазон формируется тремя элементами: начало, конец и тип протяжённости (символ `..` или `...`).
      Начало и конец должны быть одного типа данных (одного класса) и быть перечислимыми, что значит, иметь метод `.succ`.
      
      Пример диапазонов
      
      ``` rb
      "a".."z"
      "a"..."z" # то же, что и "a".."y"
      1..100
      1...100 # то же, что и 1..99
      ```
      
      Диапазон-мотоцикл `(..)` проезжает от первого указанного объекта к его `.succ` (succedent — «последующему»),
      и до последнего включительно. Три точки — то же, но мотоцикл остановился прямо перед последним элементом. 
      
      Ещё раз:
      
      `1..99 ≣ 1...100`

      #### Символы
      
      В Ruby есть особый класс `Symbol`. Синтаксически объекты этого класса обозначаются двоеточием.

      Например, `:a`, `:b`, `:symbol`.

      Символ похож на строку (`String`). Одно из главных отличий заключается в том, что у каждого символа есть только один экземпляр.

      Что это означает на практике? И в чём отличие от строки?

      Например, у нас есть такие объекты:

      ```
      a = "slovo"
      b = "slovo"
      c = "slovo"

      d = :slovo
      e = :slovo
      f = :slovo
      ```
      
      Дело в том, что в этом примере объекты `a`, `b` и `c` — это три разных объекта, они ссылаются на разные ячейки в памяти компьютера.

      А вот объекты `d`, `e` и `f` — это всё один объект. В этом легко убедиться:

      ```
      a.object_id #=> 47103948599080
      b.object_id #=> 47103948574540
      c.object_id #=> 47103948569400

      d.object_id #=> 1294428
      e.object_id #=> 1294428
      f.object_id #=> 1294428
      ```

      Символы часто используются в хэшах в качестве ключей. Одна из причин этого вытекает из свойств символов иметь лишь один экземпляр. Это позволяет экономить потребление памяти компьютера.

      Ещё одно свойство символов — статичность. Т.е. к ним нельзя применить методы, подобные `downcase` или `+`.

      И ещё одно важное применение символов, когда к ним применяется метод `to_proc`.

      ```
      downator = :downcase.to_proc
      downator.call('STROKA') #=> "stroka"
      ```

      Как это работает? Дело в том, что в переменной `downator` хранится блок `proc { |arg| arg.downcase }`

      На практике такое свойство часто применяют при операциях с массивами, например:

      ```
      ['STROKA', 'SLOVO'].map(&:downcase) #=> ["stroka", "slovo"]
      ```
    </details>
1. Какие типы данных бывают в ruby?
    <details>
      <summary>Ответ</summary>
      Данные любого типа в Ruby суть объекты тех или иных классов. Самые используемые встроенные типы данных:
      
      * Fixnum (целые числа, меньшие 2<sup>30</sup>),
      * Bignum (целые числа, большие 2<sup>30</sup>),
      * Float (числа с плавающей запятой),
      * Array (массивы),
      * String (строки),
      * Hash (ассоциативные массивы).
      
      ![Все абстрактные типы данных](https://i106.fastpic.ru/big/2019/0125/0a/f49b98f602f0ea8d8df62fd809e9320a.png)
    </details>
1. Какие структуры есть в ruby?

    <details>
      <summary>Ответ</summary>
      Что такое struct, abstract, open struct
      Структуры в Руби следующие:

      * `struct`
      * `abstract`
      * `openstruct`

      Структуры позволяют так же работать с методами по примеру полного аналога класса.  Полностью заменяют классы и возможно даже немного удобнее их. Но все пишут что не надо заменять структуры на классы полностью, они могут быть хороши только в не больших размерах и объемах коллекций.

      struct и open struct это упрощенная форма создания классов, в котором мы указываем что должно быть передано в struct для вывода программы.

      * struct — принимает четкое кол-во параметров для вывода программы.

      ``` rb
      person = :name, :age

      p.name = "Karthik"
      p.age = 30

      puts "Hello, I am #{p.name}, age #{p.age}"
      ```

      либо

      ``` rb
      person =  :name, :age

      p =  "Karthik", 30

      puts "Hello, I am #{p.name}, age #{p.age}"
      ```

      OpenStruct — не ругается, если параметров передано больше чем есть.

      ``` rb
      require 'ostruct'

      p.name= "Karthik"
      p.age = 30

      puts "Hello, I am #{p.name}, age #{p.age}"
      ```
    </details>

1. Что такое `loop`, `while`, `map`, `each`?

    <details>
      <summary>Ответ</summary>

      `loop`, `while` — это управляющие конструкции, создающие циклы, повторение кода по условию/без условий.

      `each`, `map` — итераторы, перебирают все элементы у объекта (унаследованы от `Numerable`).

      Итераторы — это методы, которые принимают блоки и выполняют код в блоках для элементов коллекций (массивов, интервалов или хэшей).

      https://www.rubyguides.com/ruby-tutorial/loops/

      https://www.rubyguides.com/2018/10/ruby-map-method/

      http://rubycode.ru/ruby/osnovy/57-chislovye-iteratory.html

      http://queirozf.com/entries/ruby-map-each-collect-inject-reject-select-quick-reference
    </details>

1. Чем отличается `each` от `map` ?

    <details>
      <summary>Ответ</summary>
      `each` занимается просто перебором, `map` занимается перебором и конечным выводом измененного массима, также можно `map` вызвать с помощью bang-меттода для изменения исходного массива.
    </details>

1. Какие еще циклы вы знаете?

    <details>
      <summary>Ответ</summary>

      `times`, `upto`, `downto`, `until`, `for * in *`

      https://i-love-ruby.gitlab.io/#_loops
    </details>

1. Какие переменные бывают, где они используются, где они доступны (поле видимости)?

    <details>
      <summary>Ответ</summary>

      Локальные переменные `variable` — локальная переменная, она доступна только в той области видимости, где была определена.

      Переменные экземпляра класса `@variable` — доступны только в методах экземпляра класса, где они определены. При первом вызове возвращают `nil`.

      Глобальные переменные `$variable` — область видимости — вся программа (опасно использовать, т.к. потом сложно изменить, где и кто её поменял).

      Переменные класса `@@variable` — область видимости — класс в котором они определены и все экземпляры данного класса.

      http://rubycode.ru/ruby/osnovy/54-oblast-vidimosti-i-tipy-obektov.html
    </details>

1. Что такое переменная с одной `@` и переменная с двумя `@@`?

    <details>
      <summary>Ответ</summary>

      Переменные экземпляра класса `@variable` — начинаются с `@`. Переменные экземпляра класса доступны в методах экземпляра класса, где они определены.

      Переменные класса `@@variable` — начинаются с двух символов `@`. Их область видимости — класс в котором они определены и все экземпляры данного класса.
    </details>

1. Чем `require` отличается от `require_relative`?

    <details>
      <summary>Ответ</summary>

      С возможностью указания абсолютного пути и относительного `require` подключает файлы/гемы по относительному пути в строгом соответствии `./1/ruby.rb`, начиная с корня приложения `require_relative` подключает файлы без относительного пути и без указания разрешения файла, запускает прогу из той же директории, где лежит файл запуска `require_relative '1/ruby.rb'`.

      http://ruby.qkspace.com/ruby-require-require_relative
    </details>

1. Что такое гемы? Как с ними работать?
1. Как создать геттер и сеттер методы в ruby?

    <details>
      <summary>Ответ</summary>
      C помощью методов

      - `attr_reader`
      - `attr_writer`
      - `attr_accessor` — объединяет attr_reader и attr_writer

      ``` rb
      class Tovar
        # Метод для установки цены
        def price=(price)
          @price = price
        end

        def price
          @price
        end
      end
      ```

      http://rubyclub.blogspot.com/2012/10/ruby_15.html

      http://findnerd.com/list/view/How-to-create-getter-and-setter-methods-in-Ruby/13615/
    </details>

1. Что такое `attr_reader`, `attr_writer`, `attr_accessor`?

    <details>
      <summary>Ответ</summary>
      Все классы наследуют методы `Module`.
      
      `attr_reader`, `attr_writer`, `attr_accessor` являются его методами.

      Что делают эти методы внутри класса?

      `attr_reader` создаёт переменную экземпляра и метод-геттер, который возвращает её значение

      Эти записи эквивалентны:

      ```
      attr_reader :name

      def name
        @name
      end
      ```

      `attr_writer` создаёт метод-сеттер, позволяющий изменять переменную экземпляра.

      Эти записи эквивалентны:

      ```
      attr_writer :name

      def name=(name)
        @name = name
      end
      ```

      `attr_accessor` объединяет функционал `attr_reader` и `attr_writer`.

      http://ruby-doc.org/core-2.5.1/Module.html#method-i-attr_reader

      http://ruby-doc.org/core-2.5.1/Module.html#method-i-attr_writer

      http://ruby-doc.org/core-2.5.1/Module.html#method-i-attr_accessor
    </details>

1. Что означает ключевое слово `self`?

    <details>
      <summary>Ответ</summary>
      `self` относится к самому объекту, вызывает сам себя, без создания класса. Обычно применяется к методам внутри класса, чтобы можно вызвать без создания нового экземпляра класса.

      Так же можно сообщить что все методы будут `self`, делается с помощью `class << self`.
    </details>

1. Что такое `super`-методы и как они работают/где применяются?
1. Что такое модуль в ruby? Какая разница между классом и модулем?

    <details>
      <summary>Ответ</summary>
      Модули в Руби похожи на классы в том, что они содержат набор методов, константы, другие модули и определения классов.

      Модули задаются как классы, только слово `module` используется вместо `class`.

      В отличие от классов создать объекты на основе модуля нельзя, модуль не может иметь подклассы. Вместо этого вы добавляете недостающую функциональность класса или отдельного объекта с помощью модуля.

      Модули – одиночки, нет иерархии и наследования.

      https://habr.com/post/49353/
    </details>

1. Какие виды наследования поддерживаются в ruby?

    <details>
      <summary>Ответ</summary>

      Прямое наследование от класса, остальное наследование можно симитировать как множественное, с помощью модулей, через подключение в классе с помощью include/extend:

      * `include` — необходимо создать экземпляр класса, чтобы задействовать логику модуля;
      * `extend` — позволяет включить дополнительное расширение или функциональность без создания экземпляра класса, непосредственно в используемом классе.
    </details>

1. Чем отличается `include` от `extend`? Что такое `prepend`?

    <details>
      <summary>Ответ</summary>

      https://habr.com/post/143483/

      https://inet777.ru/comments/8436/metod-module-prepend-v-ruby-2

      C помощью `prepend` методы модуля устанавливаются первоочередными при поиске метода в классе, в который включен модуль.
    </details>

1. Реализация множественного наследования в ruby?

    <details>
      <summary>Ответ</summary>
      Реализация возможна через module с помощью подключения `include`/`extend`.
    </details>

1. Какие есть способы вызова методов в ruby?

    <details>
      <summary>Ответ</summary>
      * `.call` — не может вызвать методы без нового класса

      * `.send` — может вызвать методы без нового класса

      * `.eval` — не используется, так как очень медленный
      http://quabr.com/35400337/ruby-send-vs-call-method
    </details>

1. Что такое `proc`, `lambda`, `block`? И какие отличия есть между ними?

    <details>
      <summary>Ответ</summary>
      Это анонимные функции, которые представляют из себя блоки.

      `lambda` требует чтобы кол-во аргументов в блоке, соответствовало преданным в блок, так же `lambda` возвращает значение без блока, можно вызвать на переменной метод `call` и передать к примеру `return 'any'`, `lambda` выведет.

      `proc` не требует и может работать без передачи аргументов, но не может вызваться методом `call` и вернуть переданное значение методом `return`.

      `block` это кусочек ruby кода, который заключен в фигурные скобки и блок выполняется для каждого массива значений.
    </details>

1. Многопоточность в ruby?
1. Какие сервера бывают под Ruby?

    <details>
      <summary>Ответ</summary>
      https://www.8host.com/blog/kratkij-obzor-veb-serverov-dlya-prilozhenij-ruby/
    </details>

