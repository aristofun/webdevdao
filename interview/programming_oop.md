# Общие вопросы по программированию и ООП с собеседований

1. Что такое ООП? Назвать 3 принципа ООП и их значение?

    <details>
      <summary>Ответ</summary>
      ООП - Методология программирования, основанная на представлении программы в виде совокупности объектов, каждый
      из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
      
      Основные принципы ООП:
    
      `Инкапсуляция`, `Наследование` и `Полиморфизм`

      * `Инкапсуляция` — способность объекта быть черным ящиком и скрывать методы и детали реализации — двигатель автомобиля.
      * `Наследование` — одни типы данных, могут принимать данные и функциональность других типов данных.

      1 Пример: Класс животное с четырьмя ногами, произносить голос, прыгать, бегать и любить играть будут наследоваться кошками, собаками.

      2 Пример: Это эволюция человека из обезьяны.

      3 Пример: Кресло и табуретка и на том, и на другом можно сидеть, но у кресла есть еще и мягкая часть

      * `Полиморфизм` — объекты с одинаковой спецификацией, могут иметь разные реализации.

      1 Пример: Собаки и кошки могут издавать звук, гавкать и мяукать, хотя спецификация у них одна — животное.

      2 Пример: Класс автомобиль — это абстрактный класс, но у него есть полиморфные объекты, к примеру мой авто и авто моего соседа, разные, разный цвет, тип двигателя, салон, собственник авто

      * `Интерфейс` — Совокупность публичных методов объекта составляют его интерфейс. Все что видно и не скрыто в private и protected.

      Возможность перекрывать методы в потомках — полиморфизм.
    </details>

1. Чем отличаются статическая и динамическая типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Статическая типизация — принцип программирования, когда переменная связывается с определённым типом в момент объявления и её тип не может быть изменён позже.

      Например, `a` — это `Integer`. В этом случае позже мы не сможем присвоить, например, значение `a = "slovo"`, это вызовет ошибку.

      Статическая типизация используется языками Ada, C, C++, C#, Go, JADE, Java, Fortran, Haskell, ML, Pascal, Scala.

      Динамическая типизация — противоположный принцип программирования, когда переменная связывается с типом в момент присваивания значения, а не в момент объявления. Таким образом, одной и той же переменной в разных участках программы можно присваивать значения различных типов.

      Динамическая типизация используется языками Perl, Smalltalk, Python, Objective-C, Ruby, JavaScript, TypeScript, Groovy, ColdFusion, Lua, Lisp, PHP.

      https://www.youtube.com/watch?v=1dwJvRw_h7A&t=168
    </details>

1. Чем отличаются сильная и слабая типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Сильная типизация — принцип, при котором взаимодействующие объекты должны быть совместимыми по типу. 

      Например, выражение `x = 5 + "y"` вызовет ошибку в Ruby.

      Языки с сильной типизацией: Java, Ruby, Python, Haskell, Lisp.

      Слабая типизация — обратный принцип, при котором взаимодействующие объекты могут быть несовместимыми по типу и это не вызовет ошибку.

      Например, выражение `$x = 5 + "y"` не вызовет ошибку, присвоит переменной значение `5`.
      
      Языки со слабой типизацией: C, JavaScript, Visual Basic, PHP.

      https://www.youtube.com/watch?v=1dwJvRw_h7A&t=284
    </details>

1. Чем отличаются явная и неявная типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Явная типизация — принцип, при котором тип новых переменных нужно задавать явно.

      Языки с явной типизацией: C++, Delphi, C#, Java

      Неявная типизация — принцип, при котором интерпретатор/компилятор сам определеяет тип переменной.

      Языки с неявной типизацией: Ruby, Python, PHP, Lua, JavaScript, Perl.

      https://ru.wikipedia.org/wiki/Явное_назначение_типов
    </details>

1. Что такое duck typing?

    <details>
      <summary>Ответ</summary>
      Вид динамической типизации, применяемой в некоторых языках программирования.

      То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.

      Если объект обладает необходимыми методами, которыми должен обладать, то мы считаем что это нужный нам объект. 
      Если что-то выглядит как утка и крякает как утка, то должно быть это утка. Отсюда и название "duck typing". 

    </details>

1. Принципиальное различие скриптовых и «обычных» языков?

    <details>
      <summary>Ответ</summary>
      Скриптовый язык программирования — язык программирования, разработанный для записи «сценариев», последовательностей операций, которые пользователь может выполнять на компьютере.

      Интерпретируется с помощью интерпретатора. Имеет динамическую типизацию.

      Интерпретация — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).
    </details>

1. Что такое `namespace` и зачем их используют?

    <details>
      <summary>Ответ</summary>

      `namespace` — это пространство имен, обычно используется для разделения функционала и названием классов.

      К примеру:

      * `Admin::User`
      * `Moderator::User`
      * `Editor::User`
    </details>

1. В чем разница между процессом и потоком?

    <details>
      <summary>Ответ</summary>
      Процесс — экземпляр программы во время выполнения. Имеет хотя бы 1 поток.
      Два процесса не знают друг о друге без настройки межпроцессного взаимодействия. Потоки же совместно используют
      данные своих состояний. Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса,
      это изменение сразу же становится видно другим потокам этого процесса.
      
      Подробнее [тут](https://tproger.ru/problems/what-is-the-difference-between-threads-and-processes/)
     
    </details>
    
1. Объяснить, что такое кеширование? Какое бывает кэширование?

    <details>
      <summary>Ответ</summary>
      Кэширование — это один из способов оптимизации Web приложений. В любом приложении встречаются медленные операции
      (SQL запросы или запросы к внешним API), результаты которых можно сохранить на некоторое время.
      Это позволит выполнять меньше таких операций, а большинству пользователей показывать заранее сохраненные данные(кэш браузера).
    </details>
    
1. Куда быстрее добавить элемент в массиве(хеше) в середину или в конец?

    <details>
      <summary>Ответ</summary>
      В конец, так как сначала нужно выгрузить все значения, пройтись по ним, определить порядок и затем добавить в начало, в конец просто добавляется
    </details>

1. Какие есть 3 уровня контроля доступа для методов в классе? Объяснить каждый.

    <details>
      <summary>Ответ</summary>

      * `public` — это общий метод классов, не указывается в коде.
      * `private` — вызывается только внутри методов класса, без вывода вне класса из вне.
      * `protected` — вызывается всеми классами и доступен дочерним классам для переопределения. `SportCar < Car`.

      Если метод будет доступен клиенту — `public`, если нет - это `private`.

      Единственное отличие `private` от `protected` — в private нельзя вызывать методы `self`, в protected можно. Есть соглашение — private используется только если не нужно давать доступ дочерним классам.
    </details>

1. Что такое класс? Что такое объект (экземпляр класса)? В чём разница?

    <details>
      <summary>Ответ</summary>
      Класс — это особый элемент, описывающий структуру объекта и его реализацию.

      Образно говоря, класс — это шаблон или чертёж, по которому изготавливаются новые объекты.

      Класс — это особый объект, который несёт в себе знания о всех методах своих экземпляров (instance methods). При помощи метода класса `.new` можно создавать неограниченное число таких экземпляров.

      Экземпляр класса — это готовая сущность класса.

      К примеру, класс Собака, имеет в себе модель, которая бегает на 4 лапах, гавкает и не любит кошек.

      В свою очередь в классе Собака можно выделить классы Лабрадор, Доберман, Сенбернар и т.д. Они наследуют определённые методы и переменные от класса Собака, но имеют и свои.

      И уже по этим классам, как по чертежам, можно изготовить новые объекты (экземпляры класса) с набором заготовленных характеристик — Шарик, Мухтар, Каштанка и т.д.
    </details>

1. Что такое конструктор? Инициализация объекта?

    <details>
      <summary>Ответ</summary>

      Конструктор это метод `initialize`, который создается в момент инициализации класса.

      Обычно в инишалайзе сразу указывают набор полей, к примеру нулевую скорость, высоту, позитивные значения `initialize` задает состояние объекта.
    </details>

1. Что такое MVC? Почему его используют?

    <details>
      <summary>Ответ</summary>
      MVC — Model, View, Controller. Это паттерн программирования используемый в Rails.

      В нем есть четкое разграничение что за что отвечает.

      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
    </details>

1. Как взаимодействуют компоненты MVC между собой? Схема паттерна в общем виде.

    <details>
      <summary>Ответ</summary>
      Все идет через контроллер, модель обращается к контроллеру, контроллер далее обращается ко вьюхе и отдает запрашиваемую информацию.
      
      ![Схема взаимодействия](https://i.stack.imgur.com/tcBUT.png)
    </details>

1. Что такое REST? Почему его используют?

    <details>
      <summary>Ответ</summary>
      Архитектурный стиль взаимодействия компонентов распределённого приложения в сети

      REST — достаточно распространенный в интернете способ взаимодействия клиентских приложений и сервисов.

      Сервис, написанный с учетом ограничений и правил REST принято называть RESTful.

      То есть REST — это набор принципов и ограничений взаимодействия клиента и сервера в сети интернет, использующий существующие стандарты (HTTP протокол, стандарт построения URL, форматы данных JSON и XML) в ходе взаимодействия.

      Взаимодействие с ресурсами осуществляется с помощью вызова URL ресурса и стандартных команд HTTP (GET, POST, PUT и DELETE).

      Эти операции обычно соответствуют операциям с объектом, например, так:

      * Create POST (с пустым ID объекта)
      * Read GET
      * Update PUT (с существующим ID объекта)
      * Delete DELETE

      http://sap.pitroff.ru/tehnologii/rest/rest-eto-ne-pro-otdyih-chast-pervaya-chto-takoe-rest/

      https://code.tutsplus.com/ru/tutorials/a-beginners-guide-to-http-and-rest--net-16340

      https://en.wikipedia.org/wiki/Representational_state_transfer

      http://eax.me/rest/
    </details>
   
1. Что такое CRUD?

    <details>
      <summary>Ответ</summary>
      Cокращённое именование 4 базовых функций при работе с хранилищами данных приложения.

      В Rails ресурсный маршрут предоставляет сопоставление между методами HTTP и URL к экшнам контроллера.

      По соглашению, каждый экшн также соединяется с определенной операцией CRUD в базе данных.

      * GET 	`/photos` 	`photos#index` 	отображает список всех фото
      * GET 	`/photos/new` 	`photos#new` 	возвращает форму HTML для создания нового фото
      * POST 	`/photos` 	`photos#create` 	создает новое фото
      * GET 	`/photos/:id` 	`photos#show` 	отображает определенное фото
      * GET 	`/photos/:id/edit` 	`photos#edit` 	возвращает форму HTML для редактирования фото
      * PATCH/PUT 	`/photos/:id` 	`photos#update` 	обновляет определенное фото
      * DELETE 	`/photos/:id` 	`photos#destroy` 	удаляет определенное фото
    </details>

1. Что такое CRUDL?

1. Что такое RESTful API?

1. Правила построения REST API.

    <details>
      <summary>Ответ</summary>
      https://code.tutsplus.com/ru/tutorials/a-beginners-guide-to-http-and-rest--net-16340
    </details>

1. Где должна быть логика в приложении?

    <details>
      <summary>Ответ</summary>
      Логика должна быть только в модели, контроллеры и представления ничего не должны знать о бизнес-логике, используется формулировка толстые-модели и тонкие контроллеры.
    </details>

1. Для чего нужны миграции?

    <details>
      <summary>Ответ</summary>
      Миграции - это удобный способ изменять схему вашей базы данных всё время неизменным и простым образом.
      Они используют Ruby DSL. Поэтому вам не нужно писать SQL вручную, позволяя вашей схеме быть независимой от базы данных.
    </details>
    
1. Синхронные и асинхронные операции — предложить варианты решения.
1. Что такое Strong Params?

    <details>
      <summary>Ответ</summary>
      С помощью сильных параметров (strong parameters) параметры Action Controller запрещены к использованию в массовых
      назначениях Active Model до тех пор, пока они не добавлены в белый список. Это означает, что нужно будет принять
      осознанное решение о том, какие атрибуты будут доступны для массового обновления. Это лучший способ предотвратить
      случайную уязвимость, позволяющую пользователям обновлять чувствительные атрибуты модели.
      
      ```rb
      private
      
      def person_params
        params.require(:person).permit(:name, :age)
      end
      ```
      
      Подробнее [тут](http://rusrails.ru/action-controller-overview#strong-parameters)
    </details>

1. Что такое `KISS`, `DRY`, `SOLID`, `YAGNI`?

    <details>
      <summary>Ответ</summary>
      <b>KISS</b> — Keep it simple stupid ( Пиши очень простой код и очень легкий (тупой) ). Достигается в основном с помощью рефакторинга.

      https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)

      <b>DRY</b> — Don't repeat yourself ( не повторяй самого себя ). Если есть логика которая повторяется более 2 раз, ее необходимо выносить в отдельный класс/метод. Например мы используем dry, когда пишем контроллеры, так как у нас есть необходимость нахождения params, мы выносим данный метод по их поиску в отдельный метод find_params.

      https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself

      <b>YAGNI</b> — You are not gonna need it — тебе это не нужно сейчас. Не писать больше того, перед чем тебе ставят задачу.

      https://ru.wikipedia.org/wiki/YAGNI

      ### SOLID

      <b>S</b> — Принцип единственной ответственности (пример повара, официанта, гостя, они не делают что-то не из своего предназначения).

      <b>O</b> — Принцип открытости и закрытости (закрытие изменений для одного из классов, можно сделать только ответвление и наследоваться).

      <b>L</b> — Принцип подстановки Барбары Лисков (всё, что делает родительский класс, должен делать и дочерний класс, класс собака должен знать и вызываться от класса животные).

      <b>I</b> — API для клиентов должен иметь только те функции, которые ему нужны, не более. Если есть проблема с этим, нужно разбить задачу на несколько маленьких интерфейсов.

      <b>D</b> — Класс не должен зависеть от конкретного ПО, он должен зависеть от абстракции. Пример база данных SQL, сменить на базу данных Oracle or Postgres. Абстракции не должны зависеть от деталей, так как в свою очередь детали должны зависеть от абстракции.

      https://en.wikipedia.org/wiki/SOLID
    </details>

1. Какие паттерны проектирования знаете?

    <details>
      <summary>Ответ</summary>
      Есть несколько паттернов, которыми нужно пользоваться:

      https://github.com/davidgf/design-patterns-in-ruby

      https://mkdev.me/posts/neskolko-patternov-dlya-napisaniya-nadyozhnogo-ruby-koda

      https://medium.com/@kopilov.vlad/%D1%86%D0%B8%D0%BA%D0%BB-%D1%81%D1%82%D0%B0%D1%82%D0%B5%D0%B9-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BE%D0%BE%D0%BF-%D0%B2-ruby-46666b260303

      https://refactoring.guru/ru/design-patterns

      * Адаптер ( Adapter ) — https://www.youtube.com/watch?v=6xDBbYe11HQ

        Данный паттерн обеспечивает совместную работу классов с несовместимым интерфейсом путем добавления недостающей логики, к примеру через наследование класса

      * Фабричный Метод ( Factory ) — https://www.youtube.com/watch?v=ZAh3NQ9WiSg

        Говорит сам за себя, создается класс, который отвечает за постоянно используемые объекты и которые остаются неизменными, чтобы можно было не дублировать код на всех уровнях. К примеру есть игра с разными уровнями сложности, чтобы не генерировать каждый раз объекты типа деревья, машины, дома, создается класс, который будет унаследован всеми уровнями сложности.

      * Команда — ( Command ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0-d68de249a3d8

        Есть какой-то объект, с которым производятся манипуляции. Нужно предоставить функционал ставить действия по манипуляции в очередь, логировать их или откатывать. В таких случаях полезен паттерн Команда, так как он превращает операцию в самостоятельный объект.

      * Композиция — Composite — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F-21a8ff9e2075

        Данный паттерн решает задачу манипулированием вложенными объектами как одним объектом.

      * Декоратор — Decorator — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80-db3623a5c2d3

        Данный паттерн предназначенный для динамического подключения дополнительного поведения к объекту. Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

      * Интерпретатор — ( Interpreter ) — http://cpp-reference.ru/patterns/behavioral-patterns/interpreter/

        Для заданного языка определяет представление его грамматики, а также интерпретатор предложений этого языка. Отображает проблемную область в язык, язык — в грамматику, а грамматику — в иерархии объектно-ориентированного проектирования.

      * Итератор — ( Iterator ) — https://refactoring.guru/ru/design-patterns/iterator

        Это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

      * Наблюдатель — Observer — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BD%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-92803c04a1c4

        Данный паттерн создает механизм подписки одних объектов на изменение состояний других объектов.

      * Прокси — ( Proxy ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-6dbc587e5703

        Данный паттерн оборачивает собой другой объект (не меняя его интерфейс), притворяясь «оригинальным» объектом. Перехватывая все вызовы к нему, реализует дополнительную скрытую логику. Прокси может использоваться для логирования запросов к объекту, для кеширования данных, для проверки доступа к объекту и прочих задач.

      * Одиночка ( Singleton ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BE%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0-7879ae1ece3

        Данный паттерн гарантирует, что у класса будет только один экземпляр. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Является единственным экземпляром класса и остается неизменным, его нельзя вызвать через `new`, так как нельзя сделать много его копий.

      * Стратегия ( Strategy ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F-dc4917887fe8

        Данный паттерн применяется в случае, если входные данные/представление/вывод данных — одни и те же; логика обработки данных перед отдачей в представление — разное. Краткий смысл паттерна — поместить алгоритмы/логику в отдельные объекты.

      * Шаблонный метод — ( Template Method ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-e1cc3d8afe9

        Данный шаблон позволяет переложить реализацию алгоритма манипулирования данными с класса-родителя, на классы потомки, которые созданы для каждого конкретного случая. Не меняя при этом входящие данные и не переписывая публичные методы.
    </details>

1. Что такое синглтон класс?

    <details>
      <summary>Ответ</summary>
      Singleton class является единственным экземпляром класса и остается неизменным, его нельзя вызвать через new, так как нельзя сделать много его копий.

     ``` rb
     require 'singleton'

     class SuperClass
       include Singleton

       def hello
         puts "Hello, I'm an instance of SuperClass and my ID is #{object_id}"
       end
     end
     ```

     Вызов класса возможен только через .instance.
    </details>

1. Что такое толстые модели и тонкие контроллеры?
    
    <details>
      <summary>Ответ</summary>
      Толстые модели и тонкие контроллёры означают, что любая логика, не связанная с ответом на запрос, должна 
      находиться в модели. Тонкий контроллёр должен содержать лишь простой интерфейс между предоставлением и моделью.

      Вынесение любой логики, которая не относится к ответу, в модель вместо 
      контроллёра, упростит повторное обращение и позволит протестировать код вне контекста запроса.

    </details>

1. Что лучше: толстые модели и тонкие контроллеры либо толстые контроллеры и тонкие модели? Аргументировать.
1. Что такое Monkey patching?

    <details>
      <summary>Ответ</summary>
      Наследование позволяет переиспользовать и дополнять классы родителей и пользоваться дополнением классов родителей, не заботясь о дублировании кода, который необходимо будет менять в нескольких местах.

      ``` rb
      > require 'active_record'
       => true
      > {a:1, b:2}.sum
       => [:a, 1, :b, 2]
      ```

      Грубая ошибка и переопределенность основного класса.

      Где искать ответы:

      * https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
      * https://ru.wikipedia.org/wiki/Monkey_patch
    </details>

1. Что такое ORM?

    <details>
      <summary>Ответ</summary>
      Object Relational Mapping.

      Это набор классов, которые предоставляют объектно-ориентированный интерфейс для базы данных.

      Обычно упоминающаяся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных. С помощью ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL, и, в итоге, с меньшим суммарным кодом для доступа в базу данных.

      ORM (англ. Object-relational mapping) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая "виртуальную" объектную базу данных.

      http://rusrails.ru/active-record-basics
    </details>

1. Какие различия между паттернами MVC, MVVM, MVP, PM

    <details>
      <summary>Ответ</summary>
      https://habr.com/company/mobileup/blog/313538/
    </details>

