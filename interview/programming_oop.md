# Общие вопросы по программированию и ООП с собеседований

1. Что такое ООП? Назвать 3 принципа ООП и их значение?

    <details>
      <summary>Ответ</summary>
      ООП - Методология программирования, основанная на представлении программы в виде совокупности объектов, каждый
      из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
      
      Основные принципы ООП:
    
      `Инкапсуляция`, `Наследование` и `Полиморфизм`

      * `Инкапсуляция` — способность объекта быть черным ящиком и скрывать методы и детали реализации — двигатель автомобиля.
      * `Наследование` — одни типы данных, могут принимать данные и функциональность других типов данных.

      1 Пример: Класс животное с четырьмя ногами, произносить голос, прыгать, бегать и любить играть будут наследоваться кошками, собаками.

      2 Пример: Это эволюция человека из обезьяны.

      3 Пример: Кресло и табуретка и на том и на том можно сидеть, но у кресла есть еще и мягкая часть

      * `Полиморфизм` — объекты с одинаковой спецификацией, могут иметь разные реализации.

      1 Пример: Собаки и кошки могут издавать звук, гавкать и мяукать, хотя спецификация у них одна — животное.

      2 Пример: Класс автомобиль — это абстрактный класс, но у него есть полиморфные объекты, к примеру мой авто и авто моего соседа, разные, разный цвет, тип двигателя, салон, собственник авто

      * `Интерфейс` — Совокупность публичных методов объекта составляют его интерфейс. Все что видно и не скрыто в private и protected.

      Возможность перекрывать методы в потомках — полиморфизм.
    </details>

1. Чем отличаются статическая и динамическая типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Статическая типизация — принцип программирования, когда переменная связывается с определённым типом в момент объявления и её тип не может быть изменён позже.

      Например, `a` — это `Integer`. В этом случае позже мы не сможем присвоить, например, значение `a = "slovo"`, это вызовет ошибку.

      Статическая типизация используется языками Ada, C, C++, C#, Go, JADE, Java, Fortran, Haskell, ML, Pascal, Scala.

      Динамическая типизация — противоположный принцип программирования, когда переменная связывается с типом в момент присваивания значения, а не в момент объявления. Таким образом, одной и той же переменной в разных участках программы можно присваивать значения различных типов.

      Динамическая типизация используется языками Perl, Smalltalk, Python, Objective-C, Ruby, JavaScript, TypeScript, Groovy, ColdFusion, Lua, Lisp, PHP.

      https://www.youtube.com/watch?v=1dwJvRw_h7A&t=168
    </details>

1. Чем отличаются сильная и слабая типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Сильная типизация — принцип, при котором взаимодействующие объекты должны быть совместимыми по типу. 

      Например, выражение `x = 5 + "y"` вызовет ошибку в Ruby.

      Языки с сильной типизацией: Java, Ruby, Python, Haskell, Lisp.

      Слабая типизация — обратный принцип, при котором взаимодействующие объекты могут быть несовместимыми по типу и это не вызовет ошибку.

      Например, выражение `$x = 5 + "y"` не вызовет ошибку, присвоит переменной значение `5`.
      
      Языки со слабой типизацией: C, JavaScript, Visual Basic, PHP.

      https://www.youtube.com/watch?v=1dwJvRw_h7A&t=284
    </details>

1. Чем отличаются явная и неявная типизации в языках программирования?

    <details>
      <summary>Ответ</summary>
      Явная типизация — принцип, при котором тип новых переменных нужно задавать явно.

      Языки с явной типизацией: C++, Delphi, C#, Java

      Неявная типизация — принцип, при котором интерпретатор/компилятор сам определеяет тип переменной.

      Языки с неявной типизацией: Ruby, Python, PHP, Lua, JavaScript, Perl.

      https://ru.wikipedia.org/wiki/Явное_назначение_типов
    </details>

1. Что такое duck typing?

    <details>
      <summary>Ответ</summary>
      Вид динамической типизации, применяемой в некоторых языках программирования.

      То есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.

      Если объект обладает необходимыми методами, которыми должен обладить, то мы считаем что это нужный нам объект.

    </details>

1. Принципиальное различие скриптовых и «обычных» языков?

    <details>
      <summary>Ответ</summary>
      Скриптовый язык программирования — язык программирования, разработанный для записи «сценариев», последовательностей операций, которые пользователь может выполнять на компьютере.

      Интерпретируется с помощью интерпретатора. Имеет динамическую типизацию.

      Интерпретация — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).
    </details>

1. Что такое `namespace` и зачем их используют?

    <details>
      <summary>Ответ</summary>

      `namespace` — это пространство имен, обычно используется для разделения функционала и названием классов.

      К примеру:

      * `Admin::User`
      * `Moderator::User`
      * `Editor::User`
    </details>

1. В чем разница между процессом и потоком?

    <details>
      <summary>Ответ</summary>
      Процесс — экземпляр программы во время выполнения. Имеет хот я бы 1 поток.
      Два процесса не знают друг о друге без настройки межпроцессного взаимодействия. Потоки же совместно используют
      данные своих состояний. Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса,
      это изменение сразу же становится видно другим потокам этого процесса.
      
      Подробнее [тут](https://tproger.ru/problems/what-is-the-difference-between-threads-and-processes/)
     
    </details>
    
1. Объяснить, что такое кеширование? Какое бывает кэширование?

    <details>
      <summary>Ответ</summary>
      Кэширование — это один из способов оптимизации Web приложений. В любом приложении встречаются медленные операции
      (SQL запросы или запросы к внешним API), результаты которых можно сохранить на некоторое время.
      Это позволит выполнять меньше таких операций, а большинству пользователей показывать заранее сохраненные данные(кэш браузера).
    </details>
    
1. Куда быстрее добавить элемент в массиве(хеше) в середину или в конец?

    <details>
      <summary>Ответ</summary>
      В конец, так как сначала нужно выгрузить все значения, пройтись по ним, определить порядок и затем добавить в начало, в конец просто добавляется
    </details>

1. Какие есть 3 уровня контроля доступа для методов в классе? Объяснить каждый.

    <details>
      <summary>Ответ</summary>

      * `public` — это общий метод классов, не указывается в коде.
      * `private` — вызывается только внутри методов класса, без вывода вне класса из вне.
      * `protected` — вызывается всеми классами и доступен дочерним классам для переопределения. `SportCar < Car`.

      Если метод будет доступен клиенту — `public`, если нет это `private`.

      Единственное отличие `private` от `protected` — в private нельзя вызывать методы `self`, в protected можно. Есть соглашение — private используется только если не нужно давать доступ дочерним классам.
    </details>

1. Что такое класс? Что такое объект (экземпляр класса)? В чём разница?

    <details>
      <summary>Ответ</summary>
      Класс — это особый элемент, описывающий структуру объекта и его реализацию.

      Образно говоря, класс — это шаблон или чертёж, по которому изготавливаются новые объекты.

      Класс — это особый объект, который несёт в себе знания о всех методах своих экземпляров (instance methods). При помощи метода класса `.new` можно создавать неограниченное число таких экземпляров.

      Экземпляр класса — это готовая сущность класса.

      К примеру, класс Собака, имеет в себе модель, которая бегает на 4 лапах, гавкает и не любит кошек.

      В свою очередь в классе Собака можно выделить классы Лабрадор, Доберман, Сенбернар и т.д. Они наследуют определённые методы и переменные от класса Собака, но имеют и свои.

      И уже по этим классам, как по чертежам, можно изготовить новые объекты (экземпляры класса) с набором заготовленных характеристик — Шарик, Мухтар, Каштанка и т.д.
    </details>

1. Что такое конструктор? Инициализация объекта?

    <details>
      <summary>Ответ</summary>

      Конструктор это метод `initialize`, который создается в момент инициализации класса.

      Обычно в инишалайзе сразу указывают набор полей, к примеру нулевую скорость, высоту, позитивные значения `initialize` задает состояние объекта.
    </details>

1. Что такое MVC? Почему его используют?

    <details>
      <summary>Ответ</summary>
      MVC — Model, View, Controller. Это паттерн программирования используемый в Rails.

      В нем есть четкое разграничение что за что отвечает.

      https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
    </details>

1. Как взаимодействуют компоненты MVC между собой? Схема паттерна в общем виде.

    <details>
      <summary>Ответ</summary>
      Все идет через контроллер, контролер обращается к модели для получения даных из базы, далее контроллер обращается ко вьюхе и отдает запрашиваемую информацию.
      
      ![Схема взаимодействия](https://i.stack.imgur.com/tcBUT.png)
    </details>

1. Что такое REST? Почему его используют?

    <details>
      <summary>Ответ</summary>
      Архитектурный стиль взаимодействия компонентов распределённого приложения в сети

      REST — достаточно распространенный в интернете способ взаимодействия клиентских приложений и сервисов.

      Сервис, написанный с учетом ограничений и правил REST принято называть RESTful.

      То есть REST — это набор принципов и ограничений взаимодействия клиента и сервера в сети интернет, использующий существующие стандарты (HTTP протокол, стандарт построения URL, форматы данных JSON и XML) в ходе взаимодействия.

      Взаимодействие с ресурсами осуществляется с помощью вызова URL ресурса и стандартных методов HTTP (GET, POST, PUT и DELETE).

      Эти операции обычно соответствуют операциям с объектом, например, так:

      * Create POST (с пустым ID объекта)
      * Read GET (с существующим ID объекта)
      * List GET
      * Update PUT (с существующим ID объекта)
      * Delete DELETE

      http://sap.pitroff.ru/tehnologii/rest/rest-eto-ne-pro-otdyih-chast-pervaya-chto-takoe-rest/

      https://code.tutsplus.com/ru/tutorials/a-beginners-guide-to-http-and-rest--net-16340

      https://en.wikipedia.org/wiki/Representational_state_transfer

      http://eax.me/rest/
    </details>
   
1. Что такое CRUD?

    <details>
      <summary>Ответ</summary>
      Cокращённое именование 4 базовых операций при работе с ресурсами.
      `С` - Create, `R` - Read, `U` - Update, `D` - Delete

      В Rails ресурсный маршрут предоставляет сопоставление между методами HTTP и URL к экшнам контроллера.

      По соглашению, каждый экшн также соединяется с определенной операцией CRUD в базе данных.

      * GET 	`/photos` 	`photos#index` 	отображает список всех фото
      * GET 	`/photos/new` 	`photos#new` 	возвращает форму HTML для создания нового фото
      * POST 	`/photos` 	`photos#create` 	создает новое фото
      * GET 	`/photos/:id` 	`photos#show` 	отображает определенное фото
      * GET 	`/photos/:id/edit` 	`photos#edit` 	возвращает форму HTML для редактирования фото
      * PATCH/PUT 	`/photos/:id` 	`photos#update` 	обновляет определенное фото
      * DELETE 	`/photos/:id` 	`photos#destroy` 	удаляет определенное фото
    </details>

1. Что такое CRUDL?

    <details>
      <summary>Ответ</summary>
      Ранее отображение списка ресурсов относили к операции `Read`, так как это так же `GET` запрос, но без идентификатора ресурса.
      Для избежания путаницы, в абривеатуру CRUD было добавлено сокращение `L`, которое отвечает за операцию получения списка екземпляров ресурса.
      `L` - List

      * GET   `/photos`   `photos#index`  отображает список всех фото
    </details>

1. Что такое RESTfull API?

    <details>
      <summary>Ответ</summary>
      `REST` – это набор принципов и ограничений взаимодействия клиента и сервера в сети Интернет, использующий существующие стандарты
      (HTTP протокол, стандарт построения URL, форматы данных JSON и XML) при взаимодействии.

      `RESTfull API` - API-интерфейсы, соответствующие архитектурному стилю REST.

      Главными компонентами `RESTfull API` являются:

      `Client` — клиент или программа, которая запущена на стороне пользователя (на его девайсе) и инициирует коммуникацию.
      `Server` — сервер, который предоставляет API в качестве доступа к своим данным и функциям.
      `Resource` — ресурс представляет собой любой вид контента (видео, текст, картинка), который сервер может передать клиенту.
    </details>

1. Правила построения REST API.

    <details>
      <summary>Ответ</summary>
      https://code.tutsplus.com/ru/tutorials/a-beginners-guide-to-http-and-rest--net-16340
    </details>

1. Где должна быть логика в приложении?

    <details>
      <summary>Ответ</summary>
      Логика должна быть только в моделе, контроллеры и вьюхи ничего не должны знать о бизнес-логике, используется формулировка толстые-модели и тонкие контроллеры.
    </details>

1. Для чего нужны миграции?

    <details>
      <summary>Ответ</summary>
      Миграции - это удобный способ изменять схему вашей базы данных всё время неизменным и простым образом.
      Они используют Ruby DSL. Поэтому вам не нужно писать SQL вручную, позволяя вашей схеме быть независимой от базы данных.
    </details>
    
1. Синхронные и асинхронные операции — предложить варианты решения.

    <details>
      <summary>Ответ</summary>
      В синхронном коде каждая операция ожидает окончания предыдущей. Поэтому вся программа может зависнуть,
      если одна из команд выполняется очень долго.
      Асинхронный код убирает блокирующую операцию из основного потока программы, так что она продолжает выполняться,
      но где-то в другом месте, а обработчик может идти дальше. Проще говоря, главный "процесс" ставит задачу и передает ее другому независимому "процессу".

      Возьмем для примера приложение, которое подбирает фильм по указанным критериям. После того как пользователь выбрал
      параметры, программа отправляет запрос на сервер. А там происходит подбор подходящих картин.
      Обработка может длиться довольно долго. Если приложение работает синхронно, то пользователь не сможет взаимодействовать со страницей, пока не придет результат. Он не сможет даже скроллить!
      Асинхронный код позволяет скрыть от пользователя эти неприятные эффекты и сохранить подвижность страницы.
      После того как данные загрузятся, программа выведет их на экран.
    </details>

1. Что такое Strong Params?

    <details>
      <summary>Ответ</summary>
      С помощью сильных параметров (strong parameters) параметры Action Controller запрещены к использованию в массовых
      назначениях Active Model до тех пор, пока они не добавлены в белый список. Это означает, что нужно будет принять
      осознанное решение о том, какие атрибуты будут доступны для массового обновления. Это лучший способ предотвратить
      случайную уязвимость, позволяющую пользователям обновлять чувствительные атрибуты модели.
      
      ```rb
      private
      
      def person_params
        params.require(:person).permit(:name, :age)
      end
      ```
      
      Подробнее [тут](http://rusrails.ru/action-controller-overview#strong-parameters)
    </details>

1. Что такое `KISS`, `DRY`, `SOLID`, `YAGNI`?

    <details>
      <summary>Ответ</summary>
      <b>KISS</b> — Keep it simple stupid ( Пиши очень простой код и очень легкий (тупой) ). Достигается в основном с помощью рефакторинга.

      https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)

      <b>DRY</b> — Don't repeat yourself ( не повторяй самого себя ). Если есть логика которая повторяется более 2 раз, ее необходимо выносить в отдельный класс/метод. Например мы используем dry, когда пишем контроллеры, так как у нас есть необходимость нахождения params, мы выносим данный метод по их поиску в отдельный метод find_params.

      https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself

      <b>YAGNI</b> — You are not gonna need it — тебе это не нужно сейчас. Не писать больше того, перед чем тебе ставят задачу.

      https://ru.wikipedia.org/wiki/YAGNI

      ### SOLID

      При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени.

      <b>S</b> — Принцип единственной ответственности (пример повара, официанта, гостя, они не делают что-то не из своего предназначения).

      <b>O</b> — Принцип открытости и закрытости ( Закрытие изменений для одного из классов, можно сделать только ответвление и наследоваться ).

      <b>L</b> — Принцип подстановки Барбары Лисков ( все что делает родительский класс, должен делать и дочерний класс, класс собака должен знать и вызываться от класса животные ).

      <b>I</b> — API для клиентов должен иметь только те функции, которые ему нужны, не более. Если есть проблема с этим, нужно разбить на несколько маленьких интерфейсов задачу.

      <b>D</b> — Класс не должен зависеть от конкретного ПО, он должен зависеть от абстракции. Пример база данных SQL, сменить на базу данных Oracle или Postgres. Абстракции не должны зависеть от деталей, так как в свою очередь детали должны зависеть от абстракции.

      https://en.wikipedia.org/wiki/SOLID
    </details>

1. Какие паттерны проектирования знаете?

    <details>
      <summary>Ответ</summary>
      Есть несколько паттернов, которыми нужно пользоваться:

      https://github.com/davidgf/design-patterns-in-ruby

      https://mkdev.me/posts/neskolko-patternov-dlya-napisaniya-nadyozhnogo-ruby-koda

      https://medium.com/@kopilov.vlad/%D1%86%D0%B8%D0%BA%D0%BB-%D1%81%D1%82%D0%B0%D1%82%D0%B5%D0%B9-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BE%D0%BE%D0%BF-%D0%B2-ruby-46666b260303

      https://refactoring.guru/ru/design-patterns

      * Адаптер ( Adapter ) — https://www.youtube.com/watch?v=6xDBbYe11HQ

        Данный паттерн обеспечивает совместную работу классов с несовместимым интерфейсом путем добавления недостающей логики, к примеру через наследование класса

      * Фабричный Метод ( Factory ) — https://www.youtube.com/watch?v=ZAh3NQ9WiSg

        Говорит сам за себя, создается класс, который отвечает за постоянно используемые объекты и которые остаются не изменными, чтобы можно было не дублировать код на всех уровнях. К примеру есть игра с разными уровнями сложности, чтобы не генерировать каждый раз объекты типа деревья, машины, дома, создается класс, который будет унаследован всеми уровнями сложности.

      * Команда — ( Command ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0-d68de249a3d8

        Есть какой то объект с которым производятся манипуляции. Нужно предоставить функционал ставить действия по манипуляции в очередь, логировать их или откатывать. В таких случаях полезен паттерн Команда так как он превращает операцию в самостоятельный объект.

      * Композиция — Composite — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F-21a8ff9e2075

        Данный паттерн решает задачу манипулированием вложенными объектами как одним объектом.

      * Декоратор — Decorator — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80-db3623a5c2d3

        Данный паттерн предназначенный для динамического подключения дополнительного поведения к объекту. Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.

      * Интерпретатор — ( Interpreter ) — http://cpp-reference.ru/patterns/behavioral-patterns/interpreter/

        Для заданного языка определяет представление его грамматики, а также интерпретатор предложений этого языка. Отображает проблемную область в язык, язык — в грамматику, а грамматику — в иерархии объектно-ориентированного проектирования.

      * Итератор — ( Iterator ) — https://refactoring.guru/ru/design-patterns/iterator

        Это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

      * Наблюдатель — Observer — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BD%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-92803c04a1c4

        Данный паттерн создает механизм подписки одних объектов на изменение состояний других объектов.

      * Прокси — ( Proxy ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8-6dbc587e5703

        Данный паттерн оборачивает собой другой объект (не меняя его интерфейс), притворяясь «оригинальным» объектом. Перехватывая все вызовы к нему, реализует дополнительную скрытую логику. Прокси может использоваться для логирования запросов к объекту; для кеширования данных; для проверки доступа к объекту и прочих задач.

      * Одиночка ( Singleton ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D0%BE%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0-7879ae1ece3

        Данный паттерн гарантирует что у класса будет только один экземпляр. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Является единственным экземпляром класса и остается не изменным, его нельзя вызвать через `new`, так как нельзя сделать много его копий.

      * Стратегия ( Strategy ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F-dc4917887fe8

        Данный паттерн применяется в случае если входные данные/представление/вывод данных — одни и те же; логика обработки данных перед отдачей в представление — разное. Краткий смысл паттерна — поместить алгоритмы/логику в отдельные объекты.

      * Шаблонный метод — ( Template Method ) — https://medium.com/@kopilov.vlad/%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B-%D0%BD%D0%B0-ruby-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-e1cc3d8afe9

        Данный шаблон позволяет переложить реализацию алгоритма манипулирования данными с класса-родителя, на классы потомки, которые созданы для каждого конкретного случая. Не меняя при этом входящие данные и не переписывая публичные методы.
    </details>

1. Что такое синглтон класс?

    <details>
      <summary>Ответ</summary>
      Singletone class является единственным экземпляром класса и остается не изменным, его нельзя вызвать через new, так как нельзя сделать много его копий.

     ``` rb
     require 'singleton'

     class SuperClass
       include Singleton

       def hello
         puts "Hello, I'm an instance of SuperClass and my ID is #{object_id}"
       end
     end
     ```

     Вызов класса возможен только через .instance.
    </details>

1. Что такое толстые модели и тонкие контроллеры?

    <details>
      <summary>Ответ</summary>
      Согласно данной концепции контроллер должен сожержать код, который:

      * обращается к данным запроса пользователя;
      * проверяет правильность входных данных;
      * (опционально) делает базовую подготовку данных;
      * передает данные модели и извлекает результат, возвращаемый моделью;
      * возвращает запрошенные данные у модели во вьюху.

      Модель должна содержать код, который:

      * осуществляет сложную фильтрацию и проверку данных. Так как данные, которые вы извлекаете, в контроллере,
      передаются в приложение из "внешнего мира", вам необходимо приложить немало усилий, чтобы проверить данные и убедиться,
      что они не сломают вашу систему. Результатом будет безопасный вебсайт, защищенный от хакерских атак.
      * осуществляет управление данными. Ваши модели должны управлять данными: например, загружать данные из базы данных,
      сохранять в базу данных и изменять данные.
    </details>

1. Что лучше: толстые модели и тонкие контроллеры либо толстые контроллеры и тонкие модели? Аргументировать.

    <details>
      <summary>Ответ</summary>
      Лучше толстые модели и тонкие контроллеры.

      Контроллеры несут ответственность за чтение входных данных (запросов), выбор соответствующих действий (бизнес-действий)
      и возврат итоговых выходных данных (ответов).

      Модель – это слой между базой данных и приложением, в котором хранится бизнес-логика, связанная с конкретной сущностью.
      Каждая модель отвечает за отдельный объект и за его связь с другими объектами.

      Аргументы:

      * возможность тестирования модели вне контекста запроса;
      * использование scope в моделях упрощает код методов контроллера;
      * использование ассоциаций в моделях упрощает код методов контроллера;
      * изменение кода контроллера не повлияет на бизнес-логику приложения;
    </details>

1. Что такое Monkey patching?

    <details>
      <summary>Ответ</summary>
      Наследование позволяет переиспользовать и дополнять классы родителей и пользоваться дополнением классов родителей, не заботясь о дублировании кода, который необходимо будет менять в нескольких местах.

      ``` rb
      > require 'active_record'
       => true
      > {a:1, b:2}.sum
       => [:a, 1, :b, 2]
      ```

      Грубая ошибка и переопределенность основного класса.

      Где искать ответы:

      * https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
      * https://ru.wikipedia.org/wiki/Monkey_patch
    </details>

1. Что такое ORM?

    <details>
      <summary>Ответ</summary>
      Object Relational Mapping.

      Это набор классов, которые предоставляют объектно-ориентированный интерфейс для базы данных.

      Обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных. С помощью ORM, свойства и взаимоотношения этих объектов приложения могут быть с легкостью сохранены и получены из базы данных без непосредственного написания выражений SQL, и, в итоге, с меньшим суммарным кодом для доступа в базу данных.

      ORM (англ. Object-relational mapping) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных

      http://rusrails.ru/active-record-basics
    </details>

1. Какие различия между паттернами MVC, MVVM, MVP, PM

    <details>
      <summary>Ответ</summary>
      https://habr.com/company/mobileup/blog/313538/
    </details>

